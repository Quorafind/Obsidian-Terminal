import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import { copyFileSync, mkdirSync, existsSync, readFileSync } from "fs";
import { dirname, join } from "path";
import { execSync } from "child_process";

import { createRequire } from "module";
const require = createRequire(import.meta.url);

/**
 * Plugin to handle ?inline CSS imports
 * Returns CSS content as a string instead of injecting into DOM
 */
const inlineCssPlugin = {
	name: "inline-css",
	setup(build) {
		// Handle ?inline suffix for CSS files
		build.onResolve({ filter: /\.css\?inline$/ }, (args) => {
			const cssPath = args.path.replace(/\?inline$/, "");
			const resolved = require.resolve(cssPath, {
				paths: [args.resolveDir],
			});
			return {
				path: resolved,
				namespace: "inline-css",
			};
		});

		// Load and return CSS as string
		build.onLoad({ filter: /.*/, namespace: "inline-css" }, (args) => {
			const css = readFileSync(args.path, "utf8");
			return {
				contents: `export default ${JSON.stringify(css)};`,
				loader: "js",
			};
		});
	},
};

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = process.argv[2] === "production";

/**
 * Plugin to handle TypeScript path aliases (@/*)
 */
const aliasPlugin = {
	name: "alias",
	setup(build) {
		// Handle @/* imports - resolve to src/* with index.ts for directories
		build.onResolve({ filter: /^@\// }, (args) => {
			const relativePath = args.path.replace(/^@\//, "src/");
			const fullPath = join(process.cwd(), relativePath);

			// Check if it's a directory (has index.ts)
			const indexPath = join(fullPath, "index.ts");
			if (existsSync(indexPath)) {
				return { path: indexPath };
			}

			// Check if it's a .ts file
			const tsPath = fullPath + ".ts";
			if (existsSync(tsPath)) {
				return { path: tsPath };
			}

			// Return as-is and let esbuild handle it
			return { path: fullPath };
		});
	},
};

// Shared build options
const sharedOptions = {
	bundle: true,
	format: "cjs",
	target: "es2018",
	logLevel: "info",
	sourcemap: prod ? false : "inline",
	treeShaking: true,
};

// Build main plugin bundle
async function buildMain() {
	console.log("üì¶ Building main plugin...");

	await esbuild.build({
		...sharedOptions,
		banner: { js: banner },
		entryPoints: ["main.ts"],
		plugins: [aliasPlugin, inlineCssPlugin],
		external: [
			"obsidian",
			"electron",
			"@codemirror/autocomplete",
			"@codemirror/collab",
			"@codemirror/commands",
			"@codemirror/language",
			"@codemirror/lint",
			"@codemirror/search",
			"@codemirror/state",
			"@codemirror/view",
			"@lezer/common",
			"@lezer/highlight",
			"@lezer/lr",
			...builtins,
		],
		outfile: "main.js",
		watch: !prod,
	});

	console.log("‚úÖ Main plugin built successfully");
}

// Build PTY host sidecar (separate process)
async function buildPtyHost() {
	console.log("üì¶ Building PTY host sidecar...");

	await esbuild.build({
		...sharedOptions,
		banner: { js: banner },
		entryPoints: ["src/pty-host.ts"],
		// PTY host runs in Node.js context, so we only externalize node-pty
		// which will be loaded at runtime from node_modules
		external: ["node-pty", ...builtins],
		outfile: "pty-host.js",
		platform: "node",
		// Don't watch PTY host - it's a stable component
		watch: false,
	});

	console.log("‚úÖ PTY host built successfully");
}

// Main build process
async function build() {
	try {
		// Build both bundles
		await Promise.all([buildMain(), buildPtyHost()]);

		console.log("üéâ All builds completed successfully");
	} catch (error) {
		console.error("‚ùå Build failed:", error);
		process.exit(1);
	}
}

build();
