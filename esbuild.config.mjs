import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import { existsSync, readFileSync, renameSync } from "fs";
import { join } from "path";

import { createRequire } from "module";
const require = createRequire(import.meta.url);

/**
 * Plugin to handle ?inline CSS imports
 * Returns CSS content as a string instead of injecting into DOM
 */
const inlineCssPlugin = {
	name: "inline-css",
	setup(build) {
		// Handle ?inline suffix for CSS files
		build.onResolve({ filter: /\.css\?inline$/ }, (args) => {
			const cssPath = args.path.replace(/\?inline$/, "");
			const resolved = require.resolve(cssPath, {
				paths: [args.resolveDir],
			});
			return {
				path: resolved,
				namespace: "inline-css",
			};
		});

		// Load and return CSS as string
		build.onLoad({ filter: /.*/, namespace: "inline-css" }, (args) => {
			const css = readFileSync(args.path, "utf8");
			return {
				contents: `export default ${JSON.stringify(css)};`,
				loader: "js",
			};
		});
	},
};

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

// Update plugins to handle output directory
const renamePluginWithDir = {
	name: "rename-styles",
	setup(build) {
		build.onEnd(() => {
			const { outfile } = build.initialOptions;
			const outcss = outfile.replace(/\.js$/, ".css");
			const fixcss = outfile.replace(/main\.js$/, "styles.css");
			if (existsSync(outcss)) {
				console.log("Renaming", outcss, "to", fixcss);
				renameSync(outcss, fixcss);
			}
		});
	},
};

const prod = process.argv[2] === "production";

/**
 * Plugin to handle TypeScript path aliases (@/*)
 */
const aliasPlugin = {
	name: "alias",
	setup(build) {
		// Handle @/* imports - resolve to src/* with index.ts for directories
		build.onResolve({ filter: /^@\// }, (args) => {
			const relativePath = args.path.replace(/^@\//, "src/");
			const fullPath = join(process.cwd(), relativePath);

			// Check if it's a directory (has index.ts)
			const indexPath = join(fullPath, "index.ts");
			if (existsSync(indexPath)) {
				return { path: indexPath };
			}

			// Check if it's a .ts file
			const tsPath = fullPath + ".ts";
			if (existsSync(tsPath)) {
				return { path: tsPath };
			}

			// Return as-is and let esbuild handle it
			return { path: fullPath };
		});
	},
};

// Shared build options
const sharedOptions = {
	bundle: true,
	format: "cjs",
	target: "es2018",
	logLevel: "info",
	sourcemap: prod ? false : "inline",
	treeShaking: true,
};

// Build main plugin bundle
async function buildMain() {
	console.log("üì¶ Building main plugin...");

	await esbuild.build({
		...sharedOptions,
		banner: { js: banner },
		entryPoints: ["src/main.ts"],
		plugins: [aliasPlugin, inlineCssPlugin, renamePluginWithDir],
		external: [
			"obsidian",
			"electron",
			"@codemirror/autocomplete",
			"@codemirror/collab",
			"@codemirror/commands",
			"@codemirror/language",
			"@codemirror/lint",
			"@codemirror/search",
			"@codemirror/state",
			"@codemirror/view",
			"@lezer/common",
			"@lezer/highlight",
			"@lezer/lr",
			...builtins,
		],
		outfile: "main.js",
		watch: !prod,
	});

	console.log("‚úÖ Main plugin built successfully");
}

// Main build process
async function build() {
	try {
		await buildMain();
		console.log("üéâ Build completed successfully");
	} catch (error) {
		console.error("‚ùå Build failed:", error);
		process.exit(1);
	}
}

build();
