/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));

// src/pty-host.ts
var pty = __toESM(require("node-pty"));
var readline = __toESM(require("readline"));
var import_os = require("os");
var MessageType = {
  Request: "request",
  Response: "response",
  Event: "event"
};
var Method = {
  Create: "create",
  Write: "write",
  Resize: "resize",
  Kill: "kill"
};
var EventName = {
  Ready: "ready",
  Data: "data",
  Exit: "exit",
  Error: "error"
};
var PtySessionManager = class {
  constructor() {
    this.sessions = /* @__PURE__ */ new Map();
  }
  add(pid, term) {
    this.sessions.set(pid, term);
  }
  get(pid) {
    return this.sessions.get(pid);
  }
  remove(pid) {
    return this.sessions.delete(pid);
  }
  cleanup() {
    for (const [, term] of this.sessions) {
      try {
        term.kill();
      } catch (e) {
      }
    }
    this.sessions.clear();
  }
};
var IpcHandler = class {
  send(msg) {
    try {
      process.stdout.write(JSON.stringify(msg) + "\n");
    } catch (e) {
    }
  }
  sendResponse(id, result, error) {
    const msg = {
      type: MessageType.Response,
      id
    };
    if (result !== void 0)
      msg.result = result;
    if (error !== void 0)
      msg.error = error;
    this.send(msg);
  }
  sendEvent(event, params) {
    const msg = {
      type: MessageType.Event,
      event,
      params
    };
    this.send(msg);
  }
};
var PtyHost = class {
  constructor() {
    this.sessions = new PtySessionManager();
    this.ipc = new IpcHandler();
    process.stdin.resume();
    this.rl = readline.createInterface({
      input: process.stdin,
      terminal: false
    });
    this.setupEventHandlers();
  }
  setupEventHandlers() {
    this.rl.on("line", (line) => this.handleLine(line));
    this.rl.on("close", () => this.shutdown());
    process.on("uncaughtException", (err) => {
      this.ipc.sendEvent(EventName.Error, {
        message: `Uncaught Exception: ${err.message}`
      });
    });
    process.on("unhandledRejection", (reason) => {
      this.ipc.sendEvent(EventName.Error, {
        message: `Unhandled Rejection: ${reason}`
      });
    });
    process.on("SIGTERM", () => this.shutdown());
    process.on("SIGINT", () => this.shutdown());
  }
  handleLine(line) {
    const trimmed = line.trim();
    if (!trimmed)
      return;
    try {
      const msg = JSON.parse(trimmed);
      if (msg.type === MessageType.Request) {
        this.handleRequest(msg);
      }
    } catch (err) {
      this.ipc.sendResponse("", void 0, `Protocol error: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  handleRequest(msg) {
    const { id, method, params } = msg;
    try {
      switch (method) {
        case Method.Create:
          this.handleCreate(id, params);
          break;
        case Method.Write:
          this.handleWrite(params);
          break;
        case Method.Resize:
          this.handleResize(params);
          break;
        case Method.Kill:
          this.handleKill(id, params);
          break;
        default:
          this.ipc.sendResponse(id, void 0, `Unknown method: ${method}`);
      }
    } catch (err) {
      this.ipc.sendResponse(id, void 0, err instanceof Error ? err.message : String(err));
    }
  }
  handleCreate(id, params) {
    var _a;
    const file = params.file;
    const args = params.args;
    const options = params.options;
    const ptyOptions = {
      name: options.name || "xterm-256color",
      cols: options.cols,
      rows: options.rows,
      cwd: options.cwd,
      env: options.env,
      encoding: options.encoding || "utf8"
    };
    if ((0, import_os.platform)() === "win32") {
      ptyOptions.useConpty = (_a = options.useConpty) != null ? _a : false;
    }
    const term = pty.spawn(file, args, ptyOptions);
    const pid = term.pid;
    this.sessions.add(pid, term);
    term.onData((data) => {
      this.ipc.sendEvent(EventName.Data, { pid, data });
    });
    term.onExit(({ exitCode, signal }) => {
      this.ipc.sendEvent(EventName.Exit, { pid, exitCode, signal });
      this.sessions.remove(pid);
    });
    this.ipc.sendResponse(id, { pid });
  }
  handleWrite(params) {
    const pid = params.pid;
    const data = params.data;
    const term = this.sessions.get(pid);
    if (term) {
      term.write(data);
    }
  }
  handleResize(params) {
    const pid = params.pid;
    const cols = params.cols;
    const rows = params.rows;
    const term = this.sessions.get(pid);
    if (term) {
      term.resize(cols, rows);
    }
  }
  handleKill(id, params) {
    const pid = params.pid;
    const signal = params.signal;
    const term = this.sessions.get(pid);
    if (term) {
      term.kill(signal);
      this.sessions.remove(pid);
    }
    this.ipc.sendResponse(id, { success: true });
  }
  shutdown() {
    if (this.keepAliveInterval) {
      clearInterval(this.keepAliveInterval);
    }
    this.sessions.cleanup();
    this.rl.close();
    process.exit(0);
  }
  start() {
    this.keepAliveInterval = setInterval(() => {
    }, 1e3 * 60 * 60);
    this.ipc.sendEvent(EventName.Ready, { pid: process.pid });
  }
};
var host = new PtyHost();
host.start();
