#!/usr/bin/env node
/**
 * Generate multi-platform embedded modules from CI artifacts
 *
 * This script is used in CI to combine native binaries from all platforms
 * into a single embedded-modules.ts file.
 *
 * Usage: node scripts/generate-multiplatform-embed.mjs
 *
 * Expected directory structure:
 *   native-binaries/
 *     win32_x64/
 *       pty.node
 *       conpty.node
 *     darwin_x64/
 *       pty.node
 *     darwin_arm64/
 *       pty.node
 *     linux_x64/
 *       pty.node
 */

import { readFileSync, writeFileSync, existsSync, readdirSync, statSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import { createHash } from "crypto";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const ROOT_DIR = join(__dirname, "..");

// Configuration
const CONFIG = {
	electronVersion: "37.10.2",
	nodeABI: 136,
};

// Expected binaries per platform
const PLATFORM_BINARIES = {
	win32_x64: ["pty.node", "conpty.node"],
	darwin_x64: ["pty.node"],
	darwin_arm64: ["pty.node"],
	linux_x64: ["pty.node"],
};

const NATIVE_BINARIES_DIR = join(ROOT_DIR, "native-binaries");
const OUTPUT_FILE = join(ROOT_DIR, "src", "core", "embedded-modules.ts");

/**
 * Calculate SHA256 hash
 */
function sha256(buffer) {
	return createHash("sha256").update(buffer).digest("hex");
}

/**
 * Generate embedded modules from all platforms
 */
function generateMultiplatformEmbed() {
	console.log("üîÑ Generating multi-platform embedded modules...");
	console.log(`üì¶ Target: Electron ${CONFIG.electronVersion} (ABI ${CONFIG.nodeABI})`);
	console.log("");

	if (!existsSync(NATIVE_BINARIES_DIR)) {
		console.error(`‚ùå Native binaries directory not found: ${NATIVE_BINARIES_DIR}`);
		process.exit(1);
	}

	const platforms = {};
	const files = {};
	let totalSize = 0;
	let totalFileCount = 0;

	// Process each platform directory
	const platformDirs = readdirSync(NATIVE_BINARIES_DIR).filter((dir) =>
		statSync(join(NATIVE_BINARIES_DIR, dir)).isDirectory()
	);

	console.log(`üìÇ Found platforms: ${platformDirs.join(", ")}`);
	console.log("");

	for (const platformKey of platformDirs) {
		const platformDir = join(NATIVE_BINARIES_DIR, platformKey);
		const expectedFiles = PLATFORM_BINARIES[platformKey] || [];

		console.log(`üñ•Ô∏è  Processing ${platformKey}...`);

		const platformModules = {};
		const platformFiles = [];

		// Read each binary file
		const actualFiles = readdirSync(platformDir);

		for (const fileName of actualFiles) {
			// Only process expected file types
			if (!fileName.endsWith(".node") && !fileName.endsWith(".dll") && !fileName.endsWith(".exe")) {
				continue;
			}

			const filePath = join(platformDir, fileName);
			const buffer = readFileSync(filePath);
			const base64 = buffer.toString("base64");
			const hash = sha256(buffer);

			// Use filename without extension as key for .node files
			const key = fileName.endsWith(".node") ? fileName.replace(".node", "") : fileName;

			platformModules[key] = base64;
			platformFiles.push({
				name: fileName,
				key,
				size: buffer.length,
				sha256: hash,
			});

			totalSize += buffer.length;
			totalFileCount++;

			const sizeKB = Math.round(buffer.length / 1024);
			console.log(`   ‚úÖ ${fileName} (${sizeKB} KB)`);
		}

		if (Object.keys(platformModules).length > 0) {
			platforms[platformKey] = platformModules;
			files[platformKey] = platformFiles;
		} else {
			console.log(`   ‚ö†Ô∏è  No valid binaries found`);
		}

		console.log("");
	}

	if (Object.keys(platforms).length === 0) {
		console.error("‚ùå No platforms with valid binaries found!");
		process.exit(1);
	}

	// Generate TypeScript file
	const platformKeys = Object.keys(platforms).sort();
	const tsContent = `// Auto-generated file - DO NOT EDIT
// Generated at: ${new Date().toISOString()}
// Generated by: scripts/generate-multiplatform-embed.mjs

/**
 * Embedded native modules as base64 strings (Multi-platform)
 *
 * Compiled for Electron ${CONFIG.electronVersion} (ABI ${CONFIG.nodeABI})
 *
 * Supported platforms:
${platformKeys.map((k) => ` *   - ${k}`).join("\n")}
 */

/**
 * Platform-specific embedded modules
 * Key format: {platform}_{arch} (e.g., "win32_x64", "darwin_arm64")
 */
export const EMBEDDED_PLATFORMS: Record<string, Record<string, string>> = ${JSON.stringify(platforms, null, "\t")};

/**
 * File information for each platform
 */
export const EMBEDDED_FILES: Record<string, Array<{
	name: string;
	key: string;
	size: number;
	sha256: string;
}>> = ${JSON.stringify(files, null, "\t")};

/**
 * Module metadata
 */
export const MODULE_INFO = {
	generatedAt: "${new Date().toISOString()}",
	electronVersion: "${CONFIG.electronVersion}",
	nodeABI: ${CONFIG.nodeABI},
	platforms: ${JSON.stringify(platformKeys)},
	totalSize: ${totalSize},
	totalFileCount: ${totalFileCount},
} as const;

/**
 * Get embedded modules for current platform
 */
export function getEmbeddedModulesForPlatform(
	platform: string = process.platform,
	arch: string = process.arch
): Record<string, string> | null {
	const key = \`\${platform}_\${arch}\`;
	return EMBEDDED_PLATFORMS[key] || null;
}

/**
 * Get embedded file info for current platform
 */
export function getEmbeddedFilesForPlatform(
	platform: string = process.platform,
	arch: string = process.arch
): Array<{ name: string; key: string; size: number; sha256: string }> | null {
	const key = \`\${platform}_\${arch}\`;
	return EMBEDDED_FILES[key] || null;
}

/**
 * Check if current platform has embedded modules
 */
export function hasPlatformSupport(
	platform: string = process.platform,
	arch: string = process.arch
): boolean {
	const key = \`\${platform}_\${arch}\`;
	return key in EMBEDDED_PLATFORMS;
}
`;

	writeFileSync(OUTPUT_FILE, tsContent, "utf8");

	console.log("=".repeat(50));
	console.log(`üìù Generated: ${OUTPUT_FILE}`);
	console.log(`üìä Total embedded size: ${Math.round(totalSize / 1024)} KB`);
	console.log(`üìÑ Total files: ${totalFileCount}`);
	console.log(`üñ•Ô∏è  Platforms: ${platformKeys.join(", ")}`);
	console.log("=".repeat(50));
	console.log("");
	console.log("‚úÖ Multi-platform embedded modules generated successfully!");
}

// Run
try {
	generateMultiplatformEmbed();
} catch (error) {
	console.error("‚ùå Failed to generate embedded modules:", error);
	process.exit(1);
}
